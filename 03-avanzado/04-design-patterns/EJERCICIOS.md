# üéØ Ejercicios: Design Patterns
### *"Pr√°ctica Que Perfecciona"*

> *"Los patrones se aprenden implement√°ndolos, no solo ley√©ndolos"* - Pattern Master

---

## üéØ **Estructura de Ejercicios**

### üìÖ **Cronograma de 10 D√≠as**

```mermaid
gantt
    title Design Patterns - Ejercicios Pr√°cticos
    dateFormat  X
    axisFormat  %d
    
    section Creational
    Factory Method        :1, 2
    Builder Pattern       :2, 3
    Singleton            :3, 4
    
    section Structural  
    Adapter Pattern      :4, 5
    Decorator Pattern    :5, 6
    Facade Pattern       :6, 7
    
    section Behavioral
    Strategy Pattern     :7, 8
    Observer Pattern     :8, 9
    Command Pattern      :9, 10
    
    section Go Specific
    Functional Options   :10, 11
```

---

## üè≠ **D√≠a 1-2: Creational Patterns**

### üéØ **Ejercicio 1: Factory Method - Sistema de Loggers**

**Dificultad:** üü¢ Principiante

**Objetivo:** Crear un sistema de logging con m√∫ltiples implementaciones

**Requisitos:**
```go
// Implementa estas interfaces y tipos
type Logger interface {
    Log(level LogLevel, message string) error
    SetLevel(level LogLevel)
    Close() error
}

type LogLevel int

const (
    DEBUG LogLevel = iota
    INFO
    WARN
    ERROR
    FATAL
)

type LoggerFactory interface {
    CreateLogger() Logger
}

// Implementa estos loggers:
// 1. ConsoleLogger - output a consola con colores
// 2. FileLogger - output a archivo con rotaci√≥n
// 3. DatabaseLogger - output a base de datos
// 4. RemoteLogger - output a servicio remoto
```

**Tareas:**
- [ ] Implementar las 4 factories de loggers
- [ ] Crear un LoggerManager que use factories din√°micamente
- [ ] Agregar configuraci√≥n por ambiente (dev, staging, prod)
- [ ] Implementar tests unitarios para cada factory
- [ ] Agregar benchmarks de performance

**Criterios de Evaluaci√≥n:**
- ‚úÖ **Extensibilidad:** Nuevos loggers sin modificar c√≥digo existente
- ‚úÖ **Configuraci√≥n:** Cambio de logger por configuration
- ‚úÖ **Error Handling:** Manejo robusto de errores
- ‚úÖ **Performance:** Benchmarks y optimizaci√≥n
- ‚úÖ **Testing:** Cobertura > 90%

---

### üéØ **Ejercicio 2: Builder Pattern - HTTP Request Builder**

**Dificultad:** üü° Intermedio

**Objetivo:** Crear un builder fluido para construir requests HTTP complejos

**Requisitos:**
```go
// Implementa un builder que permita esto:
request := NewRequestBuilder().
    Method("POST").
    URL("https://api.example.com/users").
    Header("Content-Type", "application/json").
    Header("Authorization", "Bearer token123").
    Body(map[string]interface{}{
        "name": "John Doe",
        "email": "john@example.com",
    }).
    Timeout(30 * time.Second).
    Retry(3).
    Build()
```

**Tareas:**
- [ ] Implementar RequestBuilder con interfaz fluida
- [ ] Soporte para diferentes tipos de body (JSON, XML, Form, Raw)
- [ ] Validaci√≥n de request antes de build
- [ ] Implementar middleware chain (auth, logging, metrics)
- [ ] Crear shortcuts para requests comunes (GET, POST, PUT, DELETE)

**Bonus:**
- [ ] Builder desde archivo de configuraci√≥n
- [ ] Template system para requests comunes
- [ ] Mock builder para testing

---

### üéØ **Ejercicio 3: Singleton Pattern - Configuration Manager**

**Dificultad:** üü° Intermedio

**Objetivo:** Implementar un gestor de configuraci√≥n thread-safe

**Requisitos:**
```go
type ConfigManager interface {
    Get(key string) (interface{}, bool)
    Set(key string, value interface{})
    GetString(key string) string
    GetInt(key string) int
    GetBool(key string) bool
    LoadFromFile(filename string) error
    LoadFromEnv() error
    Watch(key string, callback func(interface{}))
}
```

**Tareas:**
- [ ] Implementar singleton thread-safe (sync.Once)
- [ ] Soporte para m√∫ltiples formatos (JSON, YAML, TOML)
- [ ] Hot reload de configuraci√≥n
- [ ] Environment variable override
- [ ] Configuration validation y type safety

**Desaf√≠o:**
- [ ] ¬øC√≥mo evitar√≠as singleton para mejor testing?
- [ ] Implementa dependency injection alternativo

---

## üèóÔ∏è **D√≠a 4-6: Structural Patterns**

### üéØ **Ejercicio 4: Adapter Pattern - Legacy API Integration**

**Dificultad:** üü° Intermedio

**Objetivo:** Integrar m√∫ltiples APIs legacy con diferentes formatos

**Escenario:**
Tienes que integrar 3 APIs diferentes:
- API REST cl√°sica (JSON)
- SOAP Service legacy (XML)  
- CSV File export system

**Requisitos:**
```go
// Interfaz unificada que quieres
type UserService interface {
    GetUser(id string) (*User, error)
    ListUsers(filter UserFilter) ([]*User, error)
    CreateUser(user *User) error
    UpdateUser(user *User) error
    DeleteUser(id string) error
}

// Adapta estas APIs legacy:
type RestAPIClient struct {
    baseURL string
    client  *http.Client
}

type SOAPClient struct {
    endpoint string
    // m√©todos SOAP espec√≠ficos
}

type CSVFileSystem struct {
    dataDir string
    // m√©todos de archivo
}
```

**Tareas:**
- [ ] Crear adapters para cada sistema legacy
- [ ] Implementar data mapping entre formatos
- [ ] Manejar diferentes tipos de error de cada sistema
- [ ] Crear factory para elegir adapter seg√∫n configuraci√≥n
- [ ] Implementar circuit breaker para calls externos

---

### üéØ **Ejercicio 5: Decorator Pattern - HTTP Middleware Chain**

**Dificultad:** üü† Avanzado

**Objetivo:** Sistema de middleware extensible para HTTP handlers

**Requisitos:**
```go
// Crea un sistema que permita esto:
handler := NewHandler(businessLogicHandler).
    WithAuth(jwtAuth).
    WithLogging(requestLogger).
    WithRateLimit(100, time.Minute).
    WithCORS(corsConfig).
    WithMetrics(metricsCollector).
    WithTimeout(30 * time.Second)

http.Handle("/api/users", handler)
```

**Tareas:**
- [ ] Implementar decorator pattern para middleware
- [ ] Crear middleware comunes (auth, logging, CORS, rate limit)
- [ ] Soporte para conditional middleware
- [ ] Middleware con configuraci√≥n din√°mica
- [ ] Error handling y recovery middleware
- [ ] Metrics y observability

**Bonus:**
- [ ] Middleware composition desde configuraci√≥n
- [ ] A/B testing middleware
- [ ] Request tracing middleware

---

### üéØ **Ejercicio 6: Facade Pattern - Payment System**

**Dificultad:** üü† Avanzado

**Objetivo:** Simplificar un sistema complejo de pagos

**Escenario:**
Tienes m√∫ltiples servicios para procesar pagos:
- PaymentValidator
- FraudDetector  
- CurrencyConverter
- PaymentProcessor
- NotificationService
- AuditLogger

**Requisitos:**
```go
// Crear una facade simple:
type PaymentFacade interface {
    ProcessPayment(payment Payment) (*PaymentResult, error)
    RefundPayment(paymentID string) error
    GetPaymentStatus(paymentID string) (*PaymentStatus, error)
}

// Que internamente coordine todos los servicios
```

**Tareas:**
- [ ] Implementar facade que coordine todos los servicios
- [ ] Manejo de transacciones y rollback
- [ ] Configuraci√≥n de pol√≠ticas de retry
- [ ] Async processing para operaciones lentas
- [ ] Comprehensive error handling

---

## ‚ö° **D√≠a 7-9: Behavioral Patterns**

### üéØ **Ejercicio 7: Strategy Pattern - Sorting Algorithms**

**Dificultad:** üü¢ Principiante

**Objetivo:** Sistema de ordenamiento con algoritmos intercambiables

**Requisitos:**
```go
type Sorter interface {
    Sort(data []int) []int
    GetComplexity() string
    GetName() string
}

type SortContext struct {
    strategy Sorter
    data     []int
}

// Implementa estos algoritmos:
// - BubbleSort
// - QuickSort  
// - MergeSort
// - HeapSort
// - RadixSort
```

**Tareas:**
- [ ] Implementar 5 algoritmos de ordenamiento
- [ ] Benchmarks de performance para cada uno
- [ ] Auto-selection de algoritmo basado en tama√±o de datos
- [ ] Visualizaci√≥n del proceso de ordenamiento
- [ ] Soporte para diferentes tipos de datos (int, string, custom)

---

### üéØ **Ejercicio 8: Observer Pattern - Stock Market System**

**Dificultad:** üü† Avanzado

**Objetivo:** Sistema de trading con notificaciones en tiempo real

**Requisitos:**
```go
type Stock struct {
    Symbol string
    Price  float64
    Volume int64
    Change float64
}

type StockObserver interface {
    OnPriceUpdate(stock Stock, oldPrice float64)
    OnVolumeSpike(stock Stock)
    OnMarketOpen()
    OnMarketClose()
    GetID() string
}

// Implementa observers:
// - Trader (alerts basados en estrategia)
// - NewsService (correlaci√≥n con noticias)
// - RiskManager (monitoring de exposici√≥n)
// - AnalyticsEngine (c√°lculo de m√©tricas)
```

**Tareas:**
- [ ] Sistema de suscripci√≥n flexible (por s√≠mbolo, categor√≠a)
- [ ] Rate limiting para observers lentos
- [ ] Event replay capability
- [ ] Persistent subscriptions
- [ ] Circuit breaker para observers que fallan

---

### üéØ **Ejercicio 9: Command Pattern - Task Queue System**

**Dificultad:** üü† Avanzado

**Objetivo:** Sistema de cola de tareas con undo/redo

**Requisitos:**
```go
type Command interface {
    Execute() error
    Undo() error
    GetID() string
    GetDescription() string
}

type TaskQueue interface {
    Submit(command Command) error
    ExecuteAll() error
    Undo(commandID string) error
    Retry(commandID string) error
    GetHistory() []CommandResult
}
```

**Tareas:**
- [ ] Implementar cola de comandos con workers
- [ ] Sistema de undo/redo robusto
- [ ] Persistent queue (survive restarts)
- [ ] Priority queue con diferentes tipos de comandos
- [ ] Batch operations y transactions
- [ ] Dead letter queue para comandos fallidos

---

## üîß **D√≠a 10: Go-Specific Patterns**

### üéØ **Ejercicio 10: Functional Options - Database Connection Pool**

**Dificultad:** üü† Avanzado

**Objetivo:** Pool de conexiones configurable con functional options

**Requisitos:**
```go
// Crear un pool configurable:
pool := NewConnectionPool(
    WithMaxConnections(100),
    WithMinConnections(10),
    WithConnectionTimeout(30*time.Second),
    WithIdleTimeout(5*time.Minute),
    WithHealthCheck(healthCheckFunc),
    WithRetryPolicy(exponentialBackoff),
    WithMetrics(metricsCollector),
    WithCircuitBreaker(circuitBreakerConfig),
)
```

**Tareas:**
- [ ] Pool thread-safe con good performance
- [ ] Health checking de conexiones
- [ ] Circuit breaker integration
- [ ] Metrics y monitoring
- [ ] Graceful shutdown
- [ ] Connection lifecycle management

---

## üèÜ **Proyecto Final: E-commerce Platform**

### üéØ **Objetivo:** Integrar m√∫ltiples patterns en un sistema completo

**Escenario:**
Crear una plataforma de e-commerce que use todos los patterns aprendidos:

```
üè™ E-commerce Platform
‚îú‚îÄ‚îÄ üè≠ Product Factory (Factory Method)
‚îú‚îÄ‚îÄ üõí Order Builder (Builder)
‚îú‚îÄ‚îÄ ‚öôÔ∏è Config Manager (Singleton)
‚îú‚îÄ‚îÄ üí≥ Payment Adapter (Adapter)
‚îú‚îÄ‚îÄ üõ°Ô∏è Security Decorators (Decorator)
‚îú‚îÄ‚îÄ üé≠ API Facade (Facade)
‚îú‚îÄ‚îÄ üí∞ Pricing Strategy (Strategy)
‚îú‚îÄ‚îÄ üìß Notification Observer (Observer)
‚îú‚îÄ‚îÄ üìù Order Commands (Command)
‚îî‚îÄ‚îÄ üîß Service Options (Functional Options)
```

**Componentes:**
1. **Product Catalog** - Factory Method para diferentes tipos de productos
2. **Order System** - Builder para √≥rdenes complejas
3. **Payment Processing** - Strategy para m√©todos de pago + Adapter para APIs
4. **Inventory Management** - Observer para stock changes
5. **User Management** - Decorator para permisos y auth
6. **Notification System** - Command pattern para async notifications
7. **Service Configuration** - Functional Options para microservices

**Evaluaci√≥n:**
- ‚úÖ **Architecture:** Uso correcto de patterns
- ‚úÖ **Code Quality:** Clean code y best practices
- ‚úÖ **Testing:** Unit tests y integration tests
- ‚úÖ **Performance:** Benchmarks y profiling
- ‚úÖ **Documentation:** README y code comments
- ‚úÖ **Deployment:** Docker y CI/CD

---

## üìä **Sistema de Evaluaci√≥n**

### üéØ **Rubrica de Evaluaci√≥n**

| Criterio          | Peso | Descripci√≥n                          |
| ----------------- | ---- | ------------------------------------ |
| **Correctness**   | 25%  | Implementaci√≥n correcta del pattern  |
| **Code Quality**  | 20%  | Clean code, naming, structure        |
| **Testing**       | 20%  | Coverage, test quality, edge cases   |
| **Performance**   | 15%  | Benchmarks, memory usage, efficiency |
| **Documentation** | 10%  | Comments, README, examples           |
| **Innovation**    | 10%  | Creative solutions, bonus features   |

### üèÖ **Niveles de Dominio**

- ü•â **Bronze (70-79%):** Implementaci√≥n b√°sica correcta
- ü•à **Silver (80-89%):** Implementaci√≥n s√≥lida con buenas pr√°cticas
- ü•á **Gold (90-95%):** Implementaci√≥n excellente con optimizaciones
- üíé **Diamond (96-100%):** Implementaci√≥n maestra con innovaciones

---

## üîß **Herramientas y Setup**

### üìã **Checklist de Desarrollo**

```bash
# Setup del proyecto
mkdir design-patterns-exercises
cd design-patterns-exercises
go mod init github.com/tu-usuario/design-patterns-exercises

# Estructura recomendada
mkdir -p {creational,structural,behavioral,go-specific}/{exercises,solutions,tests}
mkdir -p project/{cmd,internal,pkg,configs,docs}

# Herramientas necesarias
go install golang.org/x/tools/cmd/goimports@latest
go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest
go install gotest.tools/gotestsum@latest
```

### üß™ **Testing Framework**

```go
// testing_utils.go - Utilities para todos los ejercicios
package testutils

import (
    "testing"
    "time"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

// MockClock para testing de time-dependent code
type MockClock struct {
    current time.Time
}

func (m *MockClock) Now() time.Time {
    return m.current
}

func (m *MockClock) Advance(duration time.Duration) {
    m.current = m.current.Add(duration)
}

// TestTimeout wrapping para evitar tests que cuelgan
func WithTimeout(t *testing.T, timeout time.Duration, fn func()) {
    done := make(chan struct{})
    go func() {
        defer close(done)
        fn()
    }()
    
    select {
    case <-done:
        // Test completed
    case <-time.After(timeout):
        t.Fatal("Test timed out")
    }
}
```

---

## üìö **Recursos para los Ejercicios**

### üîó **Referencias √ötiles**
- üìñ [Go by Example](https://gobyexample.com/)
- üé• [Design Patterns Video Series](https://patterns.dev)
- üíª [GitHub Template](https://github.com/design-patterns-template)
- üìù [Testing Best Practices](https://golang.org/doc/tutorial/add-a-test)

### üéØ **Pr√≥ximos Pasos**
1. **Completa un ejercicio por d√≠a**
2. **Revisa las soluciones modelo**
3. **Implementa el proyecto final**
4. **Comparte tu c√≥digo para feedback**
5. **Avanza a Architecture Patterns**

---

> *"Los ejercicios transforman el conocimiento te√≥rico en sabidur√≠a pr√°ctica. ¬°Cada l√≠nea de c√≥digo te acerca a la maestr√≠a!"* - Practice Master üéØ

**¬°Que comience la pr√°ctica! üöÄ**

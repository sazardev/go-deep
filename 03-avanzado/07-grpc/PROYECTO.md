# üöÄ Proyecto Final: Sistema E-Commerce gRPC de Alta Performance

> **Objetivo**: Construir un sistema e-commerce completo utilizando gRPC con todos los patrones avanzados, streaming, seguridad, observabilidad y optimizaciones de performance.

---

## üéØ Visi√≥n del Proyecto

Desarrollar√°s un **ecosistema de microservices e-commerce** que demuestre el dominio completo de gRPC en un entorno de producci√≥n real. El sistema manejar√° operaciones cr√≠ticas como gesti√≥n de usuarios, procesamiento de √≥rdenes, pagos y notificaciones en tiempo real.

### üåü **Caracter√≠sticas Principales**

#### üèóÔ∏è **Arquitectura de Microservices**
- 7 servicios gRPC independientes
- API Gateway como punto de entrada √∫nico
- Service discovery y load balancing
- Event-driven architecture

#### üì° **Comunicaci√≥n Avanzada**
- Streaming para updates en tiempo real
- Bulk operations eficientes
- Fallback mechanisms
- Circuit breaker patterns

#### üõ°Ô∏è **Seguridad Enterprise**
- JWT authentication multi-tenant
- Role-based access control (RBAC)
- TLS mutual authentication
- Rate limiting adaptivo

#### ‚ö° **Performance de Producci√≥n**
- Connection pooling inteligente
- Response caching distribuido
- Compression autom√°tica
- Load balancing con health checks

#### üîç **Observabilidad 360¬∞**
- Distributed tracing completo
- Business metrics customizadas
- Real-time alerting
- Performance profiling

---

## üèõÔ∏è Arquitectura del Sistema

```mermaid
graph TB
    subgraph "Clients"
        WEB[Web App]
        MOBILE[Mobile App]
        ADMIN[Admin Panel]
    end
    
    subgraph "API Gateway"
        GW[gRPC Gateway]
        LB[Load Balancer]
        AUTH[Auth Middleware]
        RATE[Rate Limiter]
    end
    
    subgraph "Core Services"
        USER[User Service]
        PROD[Product Service]
        ORDER[Order Service]
        PAY[Payment Service]
        INV[Inventory Service]
        NOTIF[Notification Service]
        ANALYTICS[Analytics Service]
    end
    
    subgraph "Infrastructure"
        DB[(Database)]
        CACHE[(Redis Cache)]
        QUEUE[(Message Queue)]
        METRICS[(Metrics Store)]
    end
    
    WEB --> GW
    MOBILE --> GW
    ADMIN --> GW
    
    GW --> LB
    LB --> AUTH
    AUTH --> RATE
    
    RATE --> USER
    RATE --> PROD
    RATE --> ORDER
    RATE --> PAY
    RATE --> INV
    RATE --> NOTIF
    RATE --> ANALYTICS
    
    USER --> DB
    PROD --> DB
    ORDER --> DB
    PAY --> DB
    INV --> DB
    
    USER --> CACHE
    PROD --> CACHE
    ORDER --> CACHE
    
    ORDER --> QUEUE
    PAY --> QUEUE
    NOTIF --> QUEUE
    
    ALL_SERVICES --> METRICS
```

---

## üìã Especificaciones T√©cnicas

### üîß **Core Services**

#### 1. üë• **User Service**
**Responsabilidades:**
- Gesti√≥n completa de usuarios
- Profiles y preferencias
- Authentication y autorizaci√≥n
- User activity tracking

**API Surface:**
```protobuf
service UserService {
  // CRUD Operations
  rpc CreateUser(CreateUserRequest) returns (CreateUserResponse);
  rpc GetUser(GetUserRequest) returns (GetUserResponse);
  rpc UpdateUser(UpdateUserRequest) returns (UpdateUserResponse);
  rpc DeleteUser(DeleteUserRequest) returns (DeleteUserResponse);
  
  // Bulk Operations
  rpc BatchGetUsers(BatchGetUsersRequest) returns (BatchGetUsersResponse);
  rpc BatchCreateUsers(stream CreateUserRequest) returns (BatchCreateUsersResponse);
  
  // Search & Filtering
  rpc SearchUsers(SearchUsersRequest) returns (SearchUsersResponse);
  rpc ListUsers(ListUsersRequest) returns (stream User);
  
  // Activity & Analytics
  rpc TrackUserActivity(TrackActivityRequest) returns (TrackActivityResponse);
  rpc GetUserAnalytics(GetAnalyticsRequest) returns (GetAnalyticsResponse);
  
  // Real-time Updates
  rpc StreamUserUpdates(StreamUserUpdatesRequest) returns (stream UserUpdate);
  
  // Health & Admin
  rpc Health(google.protobuf.Empty) returns (HealthResponse);
  rpc GetMetrics(GetMetricsRequest) returns (GetMetricsResponse);
}
```

**Features Avanzadas:**
- Profile completeness scoring
- Recommendation engine integration
- Social features (following, reviews)
- Privacy controls granulares

#### 2. üõçÔ∏è **Product Service**
**Responsabilidades:**
- Cat√°logo de productos completo
- Gesti√≥n de inventario
- Pricing y promotions
- Search y recommendations

**API Surface:**
```protobuf
service ProductService {
  // Product Management
  rpc CreateProduct(CreateProductRequest) returns (CreateProductResponse);
  rpc GetProduct(GetProductRequest) returns (GetProductResponse);
  rpc UpdateProduct(UpdateProductRequest) returns (UpdateProductResponse);
  rpc DeleteProduct(DeleteProductRequest) returns (DeleteProductResponse);
  
  // Advanced Search
  rpc SearchProducts(SearchProductsRequest) returns (SearchProductsResponse);
  rpc GetProductRecommendations(GetRecommendationsRequest) returns (GetRecommendationsResponse);
  rpc FilterProducts(FilterProductsRequest) returns (stream Product);
  
  // Inventory Management
  rpc CheckAvailability(CheckAvailabilityRequest) returns (CheckAvailabilityResponse);
  rpc ReserveStock(ReserveStockRequest) returns (ReserveStockResponse);
  rpc ReleaseStock(ReleaseStockRequest) returns (ReleaseStockResponse);
  
  // Real-time Updates
  rpc StreamProductUpdates(StreamProductUpdatesRequest) returns (stream ProductUpdate);
  rpc StreamPriceChanges(StreamPriceChangesRequest) returns (stream PriceUpdate);
  
  // Analytics
  rpc GetProductAnalytics(GetProductAnalyticsRequest) returns (GetProductAnalyticsResponse);
  rpc TrackProductView(TrackProductViewRequest) returns (TrackProductViewResponse);
}
```

**Features Avanzadas:**
- Dynamic pricing engine
- A/B testing para listings
- Multi-variant products
- SEO optimization autom√°tica

#### 3. üì¶ **Order Service**
**Responsabilidades:**
- Order lifecycle management
- Payment coordination
- Shipping integration
- Order analytics

**API Surface:**
```protobuf
service OrderService {
  // Order Management
  rpc CreateOrder(CreateOrderRequest) returns (CreateOrderResponse);
  rpc GetOrder(GetOrderRequest) returns (GetOrderResponse);
  rpc UpdateOrderStatus(UpdateOrderStatusRequest) returns (UpdateOrderStatusResponse);
  rpc CancelOrder(CancelOrderRequest) returns (CancelOrderResponse);
  
  // Bulk Operations
  rpc ProcessBulkOrders(stream ProcessOrderRequest) returns (ProcessBulkOrdersResponse);
  rpc BatchUpdateOrders(BatchUpdateOrdersRequest) returns (BatchUpdateOrdersResponse);
  
  // Customer Views
  rpc GetUserOrders(GetUserOrdersRequest) returns (GetUserOrdersResponse);
  rpc SearchOrders(SearchOrdersRequest) returns (SearchOrdersResponse);
  
  // Real-time Tracking
  rpc StreamOrderUpdates(StreamOrderUpdatesRequest) returns (stream OrderUpdate);
  rpc TrackOrder(TrackOrderRequest) returns (stream OrderStatus);
  
  // Analytics
  rpc GetOrderAnalytics(GetOrderAnalyticsRequest) returns (GetOrderAnalyticsResponse);
  rpc GenerateOrderReport(GenerateReportRequest) returns (GenerateReportResponse);
}
```

**Features Avanzadas:**
- Multi-step checkout workflow
- Order splitting por warehouse
- Return/refund management
- Fraud detection integration

#### 4. üí≥ **Payment Service**
**Responsabilidades:**
- Payment processing
- Multiple payment methods
- Fraud detection
- Financial reporting

**API Surface:**
```protobuf
service PaymentService {
  // Payment Processing
  rpc ProcessPayment(ProcessPaymentRequest) returns (ProcessPaymentResponse);
  rpc RefundPayment(RefundPaymentRequest) returns (RefundPaymentResponse);
  rpc CapturePayment(CapturePaymentRequest) returns (CapturePaymentResponse);
  
  // Payment Methods
  rpc AddPaymentMethod(AddPaymentMethodRequest) returns (AddPaymentMethodResponse);
  rpc GetPaymentMethods(GetPaymentMethodsRequest) returns (GetPaymentMethodsResponse);
  rpc DeletePaymentMethod(DeletePaymentMethodRequest) returns (DeletePaymentMethodResponse);
  
  // Subscriptions
  rpc CreateSubscription(CreateSubscriptionRequest) returns (CreateSubscriptionResponse);
  rpc ManageSubscription(ManageSubscriptionRequest) returns (ManageSubscriptionResponse);
  
  // Security & Fraud
  rpc ValidatePayment(ValidatePaymentRequest) returns (ValidatePaymentResponse);
  rpc ReportFraud(ReportFraudRequest) returns (ReportFraudResponse);
  
  // Analytics
  rpc GetPaymentAnalytics(GetPaymentAnalyticsRequest) returns (GetPaymentAnalyticsResponse);
  rpc GenerateFinancialReport(GenerateFinancialReportRequest) returns (GenerateFinancialReportResponse);
}
```

**Features Avanzadas:**
- Multi-currency support
- Cryptocurrency integration
- PCI DSS compliance
- Real-time fraud scoring

#### 5. üì¶ **Inventory Service**
**Responsabilidades:**
- Stock management
- Warehouse operations
- Supply chain coordination
- Demand forecasting

**API Surface:**
```protobuf
service InventoryService {
  // Stock Management
  rpc GetStock(GetStockRequest) returns (GetStockResponse);
  rpc UpdateStock(UpdateStockRequest) returns (UpdateStockResponse);
  rpc ReserveStock(ReserveStockRequest) returns (ReserveStockResponse);
  rpc ReleaseStock(ReleaseStockRequest) returns (ReleaseStockResponse);
  
  // Warehouse Operations
  rpc TransferStock(TransferStockRequest) returns (TransferStockResponse);
  rpc ProcessWarehouseEvent(ProcessWarehouseEventRequest) returns (ProcessWarehouseEventResponse);
  
  // Real-time Updates
  rpc StreamStockUpdates(StreamStockUpdatesRequest) returns (stream StockUpdate);
  rpc StreamLowStockAlerts(StreamLowStockAlertsRequest) returns (stream LowStockAlert);
  
  // Analytics & Forecasting
  rpc GetInventoryAnalytics(GetInventoryAnalyticsRequest) returns (GetInventoryAnalyticsResponse);
  rpc GenerateDemandForecast(GenerateDemandForecastRequest) returns (GenerateDemandForecastResponse);
}
```

**Features Avanzadas:**
- Multi-warehouse support
- Just-in-time inventory
- Predictive restocking
- Loss prevention tracking

#### 6. üîî **Notification Service**
**Responsabilidades:**
- Multi-channel notifications
- Template management
- Delivery tracking
- User preferences

**API Surface:**
```protobuf
service NotificationService {
  // Notification Dispatch
  rpc SendNotification(SendNotificationRequest) returns (SendNotificationResponse);
  rpc SendBulkNotifications(stream SendNotificationRequest) returns (SendBulkNotificationsResponse);
  
  // Template Management
  rpc CreateTemplate(CreateTemplateRequest) returns (CreateTemplateResponse);
  rpc GetTemplate(GetTemplateRequest) returns (GetTemplateResponse);
  rpc UpdateTemplate(UpdateTemplateRequest) returns (UpdateTemplateResponse);
  
  // User Preferences
  rpc GetUserPreferences(GetUserPreferencesRequest) returns (GetUserPreferencesResponse);
  rpc UpdateUserPreferences(UpdateUserPreferencesRequest) returns (UpdateUserPreferencesResponse);
  
  // Real-time Delivery
  rpc StreamNotifications(StreamNotificationsRequest) returns (stream Notification);
  rpc StreamDeliveryStatus(StreamDeliveryStatusRequest) returns (stream DeliveryStatus);
  
  // Analytics
  rpc GetNotificationAnalytics(GetNotificationAnalyticsRequest) returns (GetNotificationAnalyticsResponse);
  rpc TrackNotificationEngagement(TrackEngagementRequest) returns (TrackEngagementResponse);
}
```

**Features Avanzadas:**
- Multi-channel delivery (email, SMS, push, in-app)
- Intelligent scheduling
- A/B testing para templates
- Delivery optimization

#### 7. üìä **Analytics Service**
**Responsabilidades:**
- Business intelligence
- Real-time analytics
- Reporting engine
- Data visualization

**API Surface:**
```protobuf
service AnalyticsService {
  // Event Tracking
  rpc TrackEvent(TrackEventRequest) returns (TrackEventResponse);
  rpc BatchTrackEvents(stream TrackEventRequest) returns (BatchTrackEventsResponse);
  
  // Metrics & KPIs
  rpc GetMetrics(GetMetricsRequest) returns (GetMetricsResponse);
  rpc GetRealTimeMetrics(GetRealTimeMetricsRequest) returns (stream MetricUpdate);
  
  // Reports
  rpc GenerateReport(GenerateReportRequest) returns (GenerateReportResponse);
  rpc GetDashboardData(GetDashboardDataRequest) returns (GetDashboardDataResponse);
  
  // Insights
  rpc GetBusinessInsights(GetBusinessInsightsRequest) returns (GetBusinessInsightsResponse);
  rpc GetPredictiveAnalytics(GetPredictiveAnalyticsRequest) returns (GetPredictiveAnalyticsResponse);
  
  // Data Export
  rpc ExportData(ExportDataRequest) returns (stream DataChunk);
  rpc ScheduleReport(ScheduleReportRequest) returns (ScheduleReportResponse);
}
```

**Features Avanzadas:**
- Real-time dashboards
- Machine learning insights
- Custom dimensions y metrics
- Data warehouse integration

### üåê **API Gateway**

El API Gateway act√∫a como el punto de entrada √∫nico y orquesta todas las interacciones entre servicios.

**Responsabilidades Core:**
- Request routing y load balancing
- Authentication y authorization
- Rate limiting y throttling
- Response aggregation
- Circuit breaking
- Caching inteligente

**Features Avanzadas:**
```go
type APIGateway struct {
    // Service Clients
    userClient      pb.UserServiceClient
    productClient   pb.ProductServiceClient
    orderClient     pb.OrderServiceClient
    paymentClient   pb.PaymentServiceClient
    inventoryClient pb.InventoryServiceClient
    notifClient     pb.NotificationServiceClient
    analyticsClient pb.AnalyticsServiceClient
    
    // Infrastructure
    serviceRegistry ServiceRegistry
    loadBalancer    LoadBalancer
    circuitBreaker  CircuitBreakerManager
    cache          CacheManager
    rateLimiter    RateLimiter
    
    // Observability
    tracer     trace.Tracer
    metrics    MetricsCollector
    logger     Logger
}

// Composition Patterns
func (gw *APIGateway) GetEnrichedOrder(ctx context.Context, orderID string) (*EnrichedOrder, error)
func (gw *APIGateway) ProcessCompleteCheckout(ctx context.Context, req *CheckoutRequest) (*CheckoutResponse, error)
func (gw *APIGateway) GetPersonalizedHomepage(ctx context.Context, userID string) (*Homepage, error)
func (gw *APIGateway) StreamUserActivity(req *StreamActivityRequest, stream Gateway_StreamUserActivityServer) error
```

---

## üõ†Ô∏è Implementaci√≥n T√©cnica

### üìÅ **Estructura de Proyecto**

```
grpc-ecommerce/
‚îú‚îÄ‚îÄ üìÇ proto/                          # Protocol Buffer definitions
‚îÇ   ‚îú‚îÄ‚îÄ user/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.proto
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user_service.proto
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ user_types.proto
‚îÇ   ‚îú‚îÄ‚îÄ product/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ product.proto
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ product_service.proto
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ catalog_types.proto
‚îÇ   ‚îú‚îÄ‚îÄ order/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ order.proto
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ order_service.proto
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ order_types.proto
‚îÇ   ‚îú‚îÄ‚îÄ payment/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ payment.proto
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ payment_service.proto
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ payment_types.proto
‚îÇ   ‚îú‚îÄ‚îÄ inventory/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ inventory.proto
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ inventory_service.proto
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ warehouse_types.proto
‚îÇ   ‚îú‚îÄ‚îÄ notification/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ notification.proto
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ notification_service.proto
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ template_types.proto
‚îÇ   ‚îú‚îÄ‚îÄ analytics/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ analytics.proto
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ analytics_service.proto
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ metrics_types.proto
‚îÇ   ‚îú‚îÄ‚îÄ gateway/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ gateway.proto
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ gateway_service.proto
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ composition_types.proto
‚îÇ   ‚îî‚îÄ‚îÄ common/
‚îÇ       ‚îú‚îÄ‚îÄ common_types.proto
‚îÇ       ‚îú‚îÄ‚îÄ errors.proto
‚îÇ       ‚îî‚îÄ‚îÄ pagination.proto
‚îÇ
‚îú‚îÄ‚îÄ üìÇ services/                       # Microservice implementations
‚îÇ   ‚îú‚îÄ‚îÄ user/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ server/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user_server.go
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ handlers.go
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ validation.go
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ business_logic.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ storage/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ repository.go
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ postgres.go
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ cache.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ main.go
‚îÇ   ‚îú‚îÄ‚îÄ product/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ server/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ storage/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ search/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ recommendations/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ main.go
‚îÇ   ‚îú‚îÄ‚îÄ order/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ server/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ storage/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ workflow/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ payment_integration/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ main.go
‚îÇ   ‚îú‚îÄ‚îÄ payment/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ server/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ storage/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ processors/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ fraud_detection/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ main.go
‚îÇ   ‚îú‚îÄ‚îÄ inventory/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ server/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ storage/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ warehouse/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ forecasting/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ main.go
‚îÇ   ‚îú‚îÄ‚îÄ notification/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ server/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ channels/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ templates/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ delivery/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ main.go
‚îÇ   ‚îî‚îÄ‚îÄ analytics/
‚îÇ       ‚îú‚îÄ‚îÄ server/
‚îÇ       ‚îú‚îÄ‚îÄ storage/
‚îÇ       ‚îú‚îÄ‚îÄ processing/
‚îÇ       ‚îú‚îÄ‚îÄ ml/
‚îÇ       ‚îî‚îÄ‚îÄ main.go
‚îÇ
‚îú‚îÄ‚îÄ üìÇ gateway/                        # API Gateway
‚îÇ   ‚îú‚îÄ‚îÄ server/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ gateway_server.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ composition.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routing.go
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ aggregation.go
‚îÇ   ‚îú‚îÄ‚îÄ middleware/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rate_limiting.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ circuit_breaker.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ caching.go
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ logging.go
‚îÇ   ‚îú‚îÄ‚îÄ clients/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ service_clients.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ connection_pool.go
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ load_balancer.go
‚îÇ   ‚îî‚îÄ‚îÄ main.go
‚îÇ
‚îú‚îÄ‚îÄ üìÇ pkg/                           # Shared packages
‚îÇ   ‚îú‚îÄ‚îÄ auth/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ jwt.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ permissions.go
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ middleware.go
‚îÇ   ‚îú‚îÄ‚îÄ cache/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ redis.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ memory.go
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ interface.go
‚îÇ   ‚îú‚îÄ‚îÄ database/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ postgres.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ migrations/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ connection.go
‚îÇ   ‚îú‚îÄ‚îÄ messaging/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ kafka.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ redis_pub_sub.go
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ interface.go
‚îÇ   ‚îú‚îÄ‚îÄ observability/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tracing.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ metrics.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ logging.go
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ health.go
‚îÇ   ‚îú‚îÄ‚îÄ performance/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ connection_pool.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ circuit_breaker.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rate_limiter.go
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ compression.go
‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îÇ       ‚îú‚îÄ‚îÄ validation.go
‚îÇ       ‚îú‚îÄ‚îÄ pagination.go
‚îÇ       ‚îî‚îÄ‚îÄ helpers.go
‚îÇ
‚îú‚îÄ‚îÄ üìÇ clients/                       # gRPC Client libraries
‚îÇ   ‚îú‚îÄ‚îÄ go/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ecommerce_client.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ service_clients.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ connection_manager.go
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ examples/
‚îÇ   ‚îú‚îÄ‚îÄ typescript/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ecommerce-client/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ examples/
‚îÇ   ‚îî‚îÄ‚îÄ python/
‚îÇ       ‚îú‚îÄ‚îÄ ecommerce_client/
‚îÇ       ‚îî‚îÄ‚îÄ examples/
‚îÇ
‚îú‚îÄ‚îÄ üìÇ deployment/                    # Deployment configurations
‚îÇ   ‚îú‚îÄ‚îÄ docker/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ docker-compose.yml
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ docker-compose.prod.yml
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Dockerfiles/
‚îÇ   ‚îú‚îÄ‚îÄ kubernetes/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ manifests/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ helm-charts/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ operators/
‚îÇ   ‚îú‚îÄ‚îÄ terraform/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ infrastructure/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ modules/
‚îÇ   ‚îî‚îÄ‚îÄ ansible/
‚îÇ       ‚îú‚îÄ‚îÄ playbooks/
‚îÇ       ‚îî‚îÄ‚îÄ roles/
‚îÇ
‚îú‚îÄ‚îÄ üìÇ monitoring/                    # Observability stack
‚îÇ   ‚îú‚îÄ‚îÄ grafana/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dashboards/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ datasources/
‚îÇ   ‚îú‚îÄ‚îÄ prometheus/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rules/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ config/
‚îÇ   ‚îú‚îÄ‚îÄ jaeger/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ config/
‚îÇ   ‚îî‚îÄ‚îÄ elk/
‚îÇ       ‚îú‚îÄ‚îÄ elasticsearch/
‚îÇ       ‚îú‚îÄ‚îÄ logstash/
‚îÇ       ‚îî‚îÄ‚îÄ kibana/
‚îÇ
‚îú‚îÄ‚îÄ üìÇ tests/                         # Testing suite
‚îÇ   ‚îú‚îÄ‚îÄ unit/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ gateway/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ pkg/
‚îÇ   ‚îú‚îÄ‚îÄ integration/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ service_tests/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ gateway_tests/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ end_to_end/
‚îÇ   ‚îú‚îÄ‚îÄ performance/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ load_tests/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stress_tests/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ benchmarks/
‚îÇ   ‚îú‚îÄ‚îÄ security/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth_tests/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ penetration_tests/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ vulnerability_scans/
‚îÇ   ‚îî‚îÄ‚îÄ chaos/
‚îÇ       ‚îú‚îÄ‚îÄ fault_injection/
‚îÇ       ‚îî‚îÄ‚îÄ resilience_tests/
‚îÇ
‚îú‚îÄ‚îÄ üìÇ scripts/                       # Automation scripts
‚îÇ   ‚îú‚îÄ‚îÄ build/
‚îÇ   ‚îú‚îÄ‚îÄ deploy/
‚îÇ   ‚îú‚îÄ‚îÄ testing/
‚îÇ   ‚îú‚îÄ‚îÄ monitoring/
‚îÇ   ‚îî‚îÄ‚îÄ utilities/
‚îÇ
‚îú‚îÄ‚îÄ üìÇ docs/                          # Documentation
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ openapi/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ grpc/
‚îÇ   ‚îú‚îÄ‚îÄ architecture/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ system_design.md
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ data_flow.md
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ security_model.md
‚îÇ   ‚îú‚îÄ‚îÄ deployment/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ installation.md
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ configuration.md
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ troubleshooting.md
‚îÇ   ‚îú‚îÄ‚îÄ development/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ getting_started.md
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ contributing.md
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ coding_standards.md
‚îÇ   ‚îî‚îÄ‚îÄ operations/
‚îÇ       ‚îú‚îÄ‚îÄ monitoring.md
‚îÇ       ‚îú‚îÄ‚îÄ alerting.md
‚îÇ       ‚îî‚îÄ‚îÄ disaster_recovery.md
‚îÇ
‚îú‚îÄ‚îÄ üìÑ Makefile                       # Build automation
‚îú‚îÄ‚îÄ üìÑ docker-compose.yml            # Local development
‚îú‚îÄ‚îÄ üìÑ go.mod                        # Go dependencies
‚îú‚îÄ‚îÄ üìÑ go.sum
‚îú‚îÄ‚îÄ üìÑ README.md                      # Project overview
‚îú‚îÄ‚îÄ üìÑ CHANGELOG.md                   # Version history
‚îî‚îÄ‚îÄ üìÑ LICENSE                       # License information
```

---

## üîß Especificaciones de Implementaci√≥n

### üìù **Protocol Buffers Schema**

#### **Common Types** (`proto/common/common_types.proto`)
```protobuf
syntax = "proto3";

package ecommerce.common;
option go_package = "github.com/yourname/grpc-ecommerce/proto/common";

import "google/protobuf/timestamp.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/field_mask.proto";

// Pagination
message PageRequest {
  int32 page = 1;
  int32 page_size = 2;
  string order_by = 3;
  string order_direction = 4; // ASC, DESC
}

message PageResponse {
  int32 total_count = 1;
  int32 page_count = 2;
  int32 current_page = 3;
  bool has_next = 4;
  bool has_previous = 5;
}

// Filtering
message Filter {
  string field = 1;
  FilterOperator operator = 2;
  repeated string values = 3;
}

enum FilterOperator {
  FILTER_OPERATOR_UNSPECIFIED = 0;
  FILTER_OPERATOR_EQUALS = 1;
  FILTER_OPERATOR_NOT_EQUALS = 2;
  FILTER_OPERATOR_GREATER_THAN = 3;
  FILTER_OPERATOR_LESS_THAN = 4;
  FILTER_OPERATOR_CONTAINS = 5;
  FILTER_OPERATOR_IN = 6;
  FILTER_OPERATOR_NOT_IN = 7;
}

// Metadata
message Metadata {
  map<string, string> annotations = 1;
  map<string, string> labels = 2;
}

// Address
message Address {
  string street = 1;
  string city = 2;
  string state = 3;
  string country = 4;
  string postal_code = 5;
  double latitude = 6;
  double longitude = 7;
}

// Money
message Money {
  string currency_code = 1; // ISO 4217
  int64 amount = 2; // Amount in smallest currency unit
}

// Health Check
message HealthResponse {
  HealthStatus status = 1;
  string message = 2;
  map<string, string> details = 3;
  google.protobuf.Timestamp timestamp = 4;
}

enum HealthStatus {
  HEALTH_STATUS_UNSPECIFIED = 0;
  HEALTH_STATUS_SERVING = 1;
  HEALTH_STATUS_NOT_SERVING = 2;
  HEALTH_STATUS_UNKNOWN = 3;
}
```

### üîê **Authentication y Authorization**

#### **JWT Manager Implementation**
```go
// pkg/auth/jwt.go
package auth

import (
    "context"
    "crypto/rsa"
    "fmt"
    "strings"
    "time"
    
    "github.com/golang-jwt/jwt/v4"
    "google.golang.org/grpc"
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/metadata"
    "google.golang.org/grpc/status"
)

type Claims struct {
    UserID      string            `json:"user_id"`
    Email       string            `json:"email"`
    Roles       []string          `json:"roles"`
    Permissions []string          `json:"permissions"`
    TenantID    string            `json:"tenant_id"`
    SessionID   string            `json:"session_id"`
    Metadata    map[string]string `json:"metadata"`
    jwt.RegisteredClaims
}

type JWTManager struct {
    privateKey  *rsa.PrivateKey
    publicKey   *rsa.PublicKey
    tokenExpiry time.Duration
    issuer      string
}

func NewJWTManager(privateKeyPath, publicKeyPath string, tokenExpiry time.Duration, issuer string) (*JWTManager, error) {
    // Load RSA keys
    privateKey, err := loadPrivateKey(privateKeyPath)
    if err != nil {
        return nil, fmt.Errorf("failed to load private key: %w", err)
    }
    
    publicKey, err := loadPublicKey(publicKeyPath)
    if err != nil {
        return nil, fmt.Errorf("failed to load public key: %w", err)
    }
    
    return &JWTManager{
        privateKey:  privateKey,
        publicKey:   publicKey,
        tokenExpiry: tokenExpiry,
        issuer:      issuer,
    }, nil
}

func (jm *JWTManager) GenerateToken(userID, email string, roles, permissions []string, tenantID string) (string, error) {
    now := time.Now()
    claims := &Claims{
        UserID:      userID,
        Email:       email,
        Roles:       roles,
        Permissions: permissions,
        TenantID:    tenantID,
        SessionID:   generateSessionID(),
        Metadata:    make(map[string]string),
        RegisteredClaims: jwt.RegisteredClaims{
            Issuer:    jm.issuer,
            Subject:   userID,
            Audience:  []string{"ecommerce-api"},
            ExpiresAt: jwt.NewNumericDate(now.Add(jm.tokenExpiry)),
            NotBefore: jwt.NewNumericDate(now),
            IssuedAt:  jwt.NewNumericDate(now),
            ID:        generateJTI(),
        },
    }
    
    token := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)
    return token.SignedString(jm.privateKey)
}

func (jm *JWTManager) ValidateToken(tokenString string) (*Claims, error) {
    token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
        if _, ok := token.Method.(*jwt.SigningMethodRSA); !ok {
            return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
        }
        return jm.publicKey, nil
    })
    
    if err != nil {
        return nil, fmt.Errorf("failed to parse token: %w", err)
    }
    
    claims, ok := token.Claims.(*Claims)
    if !ok || !token.Valid {
        return nil, fmt.Errorf("invalid token claims")
    }
    
    return claims, nil
}

// Authentication Interceptor
func (jm *JWTManager) AuthInterceptor(skipMethods map[string]bool) grpc.UnaryServerInterceptor {
    return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
        // Skip authentication for certain methods
        if skipMethods[info.FullMethod] {
            return handler(ctx, req)
        }
        
        // Extract token from metadata
        md, ok := metadata.FromIncomingContext(ctx)
        if !ok {
            return nil, status.Errorf(codes.Unauthenticated, "missing metadata")
        }
        
        authHeaders := md.Get("authorization")
        if len(authHeaders) == 0 {
            return nil, status.Errorf(codes.Unauthenticated, "missing authorization header")
        }
        
        tokenString := strings.TrimPrefix(authHeaders[0], "Bearer ")
        if tokenString == authHeaders[0] {
            return nil, status.Errorf(codes.Unauthenticated, "invalid authorization header format")
        }
        
        // Validate token
        claims, err := jm.ValidateToken(tokenString)
        if err != nil {
            return nil, status.Errorf(codes.Unauthenticated, "invalid token: %v", err)
        }
        
        // Add claims to context
        ctx = context.WithValue(ctx, "claims", claims)
        ctx = context.WithValue(ctx, "user_id", claims.UserID)
        ctx = context.WithValue(ctx, "tenant_id", claims.TenantID)
        
        return handler(ctx, req)
    }
}

// Authorization Interceptor
func AuthorizationInterceptor(permissions map[string][]string) grpc.UnaryServerInterceptor {
    return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
        requiredPerms, exists := permissions[info.FullMethod]
        if !exists {
            // No specific permissions required
            return handler(ctx, req)
        }
        
        claims, ok := ctx.Value("claims").(*Claims)
        if !ok {
            return nil, status.Errorf(codes.Internal, "missing claims in context")
        }
        
        // Check permissions
        if !hasAnyPermission(claims.Permissions, requiredPerms) {
            return nil, status.Errorf(codes.PermissionDenied, "insufficient permissions")
        }
        
        return handler(ctx, req)
    }
}

func hasAnyPermission(userPerms, requiredPerms []string) bool {
    permSet := make(map[string]bool)
    for _, perm := range userPerms {
        permSet[perm] = true
    }
    
    for _, required := range requiredPerms {
        if permSet[required] {
            return true
        }
    }
    
    return false
}
```

### ‚ö° **Performance Optimization**

#### **Advanced Connection Pool**
```go
// pkg/performance/connection_pool.go
package performance

import (
    "context"
    "fmt"
    "sync"
    "time"
    
    "google.golang.org/grpc"
    "google.golang.org/grpc/balancer/roundrobin"
    "google.golang.org/grpc/keepalive"
)

type ConnectionPool struct {
    mu          sync.RWMutex
    pools       map[string]*ServicePool
    config      *PoolConfig
    healthCheck HealthChecker
    metrics     MetricsCollector
}

type ServicePool struct {
    connections []*ConnectionInfo
    loadBalancer LoadBalancer
    lastUsed    int
}

type ConnectionInfo struct {
    conn         *grpc.ClientConn
    address      string
    healthy      bool
    requestCount int64
    errorCount   int64
    lastUsed     time.Time
    created      time.Time
}

type PoolConfig struct {
    MaxConnectionsPerService int
    MaxIdleTime             time.Duration
    HealthCheckInterval     time.Duration
    ConnectionTimeout       time.Duration
    KeepAlive              keepalive.ClientParameters
}

func NewConnectionPool(config *PoolConfig) *ConnectionPool {
    pool := &ConnectionPool{
        pools:   make(map[string]*ServicePool),
        config:  config,
        metrics: NewMetricsCollector(),
    }
    
    // Start background maintenance
    go pool.maintenanceLoop()
    
    return pool
}

func (cp *ConnectionPool) GetConnection(service, address string) (*grpc.ClientConn, error) {
    cp.mu.RLock()
    servicePool, exists := cp.pools[service]
    cp.mu.RUnlock()
    
    if !exists {
        return cp.createNewConnection(service, address)
    }
    
    return servicePool.getConnection(address, cp.config)
}

func (sp *ServicePool) getConnection(address string, config *PoolConfig) (*grpc.ClientConn, error) {
    // Find healthy connection
    for _, connInfo := range sp.connections {
        if connInfo.healthy && connInfo.address == address {
            connInfo.lastUsed = time.Now()
            connInfo.requestCount++
            return connInfo.conn, nil
        }
    }
    
    // Create new connection if pool not full
    if len(sp.connections) < config.MaxConnectionsPerService {
        return sp.createConnection(address, config)
    }
    
    // Use least recently used connection
    return sp.loadBalancer.SelectConnection(sp.connections).conn, nil
}

func (cp *ConnectionPool) createNewConnection(service, address string) (*grpc.ClientConn, error) {
    opts := []grpc.DialOption{
        grpc.WithInsecure(), // Use TLS in production
        grpc.WithKeepaliveParams(cp.config.KeepAlive),
        grpc.WithDefaultServiceConfig(fmt.Sprintf(`{
            "loadBalancingConfig": [{"%s":{}}],
            "healthCheckConfig": {
                "serviceName": "%s"
            }
        }`, roundrobin.Name, service)),
    }
    
    ctx, cancel := context.WithTimeout(context.Background(), cp.config.ConnectionTimeout)
    defer cancel()
    
    conn, err := grpc.DialContext(ctx, address, opts...)
    if err != nil {
        return nil, fmt.Errorf("failed to connect to %s: %w", address, err)
    }
    
    // Add to pool
    cp.mu.Lock()
    if _, exists := cp.pools[service]; !exists {
        cp.pools[service] = &ServicePool{
            connections:  make([]*ConnectionInfo, 0),
            loadBalancer: NewRoundRobinLB(),
        }
    }
    
    connInfo := &ConnectionInfo{
        conn:     conn,
        address:  address,
        healthy:  true,
        created:  time.Now(),
        lastUsed: time.Now(),
    }
    
    cp.pools[service].connections = append(cp.pools[service].connections, connInfo)
    cp.mu.Unlock()
    
    return conn, nil
}

func (cp *ConnectionPool) maintenanceLoop() {
    ticker := time.NewTicker(cp.config.HealthCheckInterval)
    defer ticker.Stop()
    
    for range ticker.C {
        cp.performMaintenance()
    }
}

func (cp *ConnectionPool) performMaintenance() {
    cp.mu.Lock()
    defer cp.mu.Unlock()
    
    for service, pool := range cp.pools {
        var healthyConnections []*ConnectionInfo
        
        for _, connInfo := range pool.connections {
            // Health check
            if cp.isConnectionHealthy(connInfo) {
                // Check if connection is too old or idle
                if time.Since(connInfo.lastUsed) < cp.config.MaxIdleTime {
                    healthyConnections = append(healthyConnections, connInfo)
                } else {
                    connInfo.conn.Close()
                    cp.metrics.RecordConnectionClosed(service, "idle_timeout")
                }
            } else {
                connInfo.conn.Close()
                cp.metrics.RecordConnectionClosed(service, "health_check_failed")
            }
        }
        
        pool.connections = healthyConnections
    }
}

func (cp *ConnectionPool) isConnectionHealthy(connInfo *ConnectionInfo) bool {
    // Implement health check logic
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    return connInfo.conn.GetState().String() == "READY"
}
```

### üîç **Observabilidad Completa**

#### **Tracing Implementation**
```go
// pkg/observability/tracing.go
package observability

import (
    "context"
    
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
    "go.opentelemetry.io/otel/trace"
    "google.golang.org/grpc"
    "google.golang.org/grpc/metadata"
)

type TracingInterceptor struct {
    tracer trace.Tracer
}

func NewTracingInterceptor(serviceName string) *TracingInterceptor {
    return &TracingInterceptor{
        tracer: otel.Tracer(serviceName),
    }
}

func (t *TracingInterceptor) UnaryServerInterceptor() grpc.UnaryServerInterceptor {
    return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
        service, method := parseFullMethod(info.FullMethod)
        
        // Start span
        ctx, span := t.tracer.Start(ctx, method,
            trace.WithSpanKind(trace.SpanKindServer),
            trace.WithAttributes(
                attribute.String("rpc.system", "grpc"),
                attribute.String("rpc.service", service),
                attribute.String("rpc.method", method),
                attribute.String("rpc.grpc.status_code", "OK"),
            ),
        )
        defer span.End()
        
        // Extract additional context from metadata
        if md, ok := metadata.FromIncomingContext(ctx); ok {
            if userID := md.Get("user-id"); len(userID) > 0 {
                span.SetAttributes(attribute.String("user.id", userID[0]))
            }
            if tenantID := md.Get("tenant-id"); len(tenantID) > 0 {
                span.SetAttributes(attribute.String("tenant.id", tenantID[0]))
            }
            if traceID := md.Get("trace-id"); len(traceID) > 0 {
                span.SetAttributes(attribute.String("trace.parent.id", traceID[0]))
            }
        }
        
        // Call handler
        resp, err := handler(ctx, req)
        
        // Record error if any
        if err != nil {
            span.RecordError(err)
            span.SetStatus(codes.Error, err.Error())
            span.SetAttributes(attribute.String("rpc.grpc.status_code", "ERROR"))
        } else {
            span.SetStatus(codes.Ok, "success")
        }
        
        return resp, err
    }
}

func (t *TracingInterceptor) StreamServerInterceptor() grpc.StreamServerInterceptor {
    return func(srv interface{}, stream grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error {
        service, method := parseFullMethod(info.FullMethod)
        
        ctx, span := t.tracer.Start(stream.Context(), method,
            trace.WithSpanKind(trace.SpanKindServer),
            trace.WithAttributes(
                attribute.String("rpc.system", "grpc"),
                attribute.String("rpc.service", service),
                attribute.String("rpc.method", method),
                attribute.Bool("rpc.streaming", true),
            ),
        )
        defer span.End()
        
        // Wrap stream with traced context
        wrappedStream := &tracedServerStream{
            ServerStream: stream,
            ctx:         ctx,
        }
        
        err := handler(srv, wrappedStream)
        if err != nil {
            span.RecordError(err)
            span.SetStatus(codes.Error, err.Error())
        } else {
            span.SetStatus(codes.Ok, "success")
        }
        
        return err
    }
}

type tracedServerStream struct {
    grpc.ServerStream
    ctx context.Context
}

func (s *tracedServerStream) Context() context.Context {
    return s.ctx
}

// Client interceptors
func (t *TracingInterceptor) UnaryClientInterceptor() grpc.UnaryClientInterceptor {
    return func(ctx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error {
        service, methodName := parseFullMethod(method)
        
        ctx, span := t.tracer.Start(ctx, methodName,
            trace.WithSpanKind(trace.SpanKindClient),
            trace.WithAttributes(
                attribute.String("rpc.system", "grpc"),
                attribute.String("rpc.service", service),
                attribute.String("rpc.method", methodName),
            ),
        )
        defer span.End()
        
        // Inject trace context into metadata
        md, ok := metadata.FromOutgoingContext(ctx)
        if !ok {
            md = metadata.New(nil)
        }
        
        // Add trace information
        md.Set("trace-id", span.SpanContext().TraceID().String())
        md.Set("span-id", span.SpanContext().SpanID().String())
        ctx = metadata.NewOutgoingContext(ctx, md)
        
        err := invoker(ctx, method, req, reply, cc, opts...)
        if err != nil {
            span.RecordError(err)
            span.SetStatus(codes.Error, err.Error())
        } else {
            span.SetStatus(codes.Ok, "success")
        }
        
        return err
    }
}
```

---

## üéØ Entregables del Proyecto

### üìù **1. C√≥digo Fuente Completo**

#### **Core Services** (7 servicios)
- [ ] User Service con autenticaci√≥n completa
- [ ] Product Service con search avanzado
- [ ] Order Service con workflow management
- [ ] Payment Service con fraud detection
- [ ] Inventory Service con forecasting
- [ ] Notification Service multi-channel
- [ ] Analytics Service con ML insights

#### **API Gateway**
- [ ] Request routing y aggregation
- [ ] Load balancing y circuit breaking
- [ ] Authentication y authorization
- [ ] Rate limiting y caching
- [ ] Response composition

#### **Infrastructure Code**
- [ ] Connection pooling avanzado
- [ ] Circuit breaker implementation
- [ ] Distributed caching
- [ ] Health checking system
- [ ] Metrics collection

### üìä **2. Documentaci√≥n T√©cnica**

#### **Architecture Documentation**
- [ ] System architecture diagrams
- [ ] Data flow documentation
- [ ] Security model documentation
- [ ] Scalability analysis
- [ ] Performance characteristics

#### **API Documentation**
- [ ] gRPC service documentation
- [ ] Protocol Buffer schemas
- [ ] Client libraries documentation
- [ ] Integration examples
- [ ] Best practices guide

#### **Operational Documentation**
- [ ] Deployment guide
- [ ] Configuration management
- [ ] Monitoring setup
- [ ] Troubleshooting guide
- [ ] Disaster recovery plan

### üê≥ **3. Deployment Infrastructure**

#### **Containerization**
- [ ] Docker images para todos los servicios
- [ ] Multi-stage builds optimizados
- [ ] Docker Compose para desarrollo local
- [ ] Docker Compose para producci√≥n
- [ ] Health checks y probes

#### **Kubernetes Deployment**
- [ ] Kubernetes manifests
- [ ] Helm charts
- [ ] Ingress configuration
- [ ] Service mesh setup (Istio)
- [ ] Auto-scaling configuration

#### **Infrastructure as Code**
- [ ] Terraform modules
- [ ] AWS/GCP/Azure deployment
- [ ] Database provisioning
- [ ] Networking setup
- [ ] Security groups/policies

### üìà **4. Observabilidad Stack**

#### **Monitoring Setup**
- [ ] Prometheus configuration
- [ ] Grafana dashboards
- [ ] Custom business metrics
- [ ] SLA/SLO definitions
- [ ] Alert rules y runbooks

#### **Logging Infrastructure**
- [ ] Structured logging implementation
- [ ] Log aggregation (ELK/Loki)
- [ ] Log retention policies
- [ ] Security event logging
- [ ] Audit trail implementation

#### **Distributed Tracing**
- [ ] Jaeger/Zipkin setup
- [ ] End-to-end trace correlation
- [ ] Performance bottleneck identification
- [ ] Service dependency mapping
- [ ] Error trace analysis

### üß™ **5. Testing Suite**

#### **Automated Testing**
- [ ] Unit tests (>80% coverage)
- [ ] Integration tests
- [ ] End-to-end tests
- [ ] Contract testing
- [ ] Security tests

#### **Performance Testing**
- [ ] Load testing scenarios
- [ ] Stress testing
- [ ] Capacity planning
- [ ] Performance benchmarks
- [ ] Latency analysis

#### **Chaos Engineering**
- [ ] Fault injection tests
- [ ] Network partition simulation
- [ ] Service failure scenarios
- [ ] Data corruption tests
- [ ] Recovery time testing

---

## ‚úÖ Criterios de Evaluaci√≥n

### üèóÔ∏è **Arquitectura y Dise√±o (25%)**

#### ‚≠ê **B√°sico (60-70%)**
- [ ] Servicios gRPC b√°sicos implementados
- [ ] Protocol Buffers correctamente definidos
- [ ] API Gateway b√°sico funcional
- [ ] Separaci√≥n de responsabilidades clara

#### ‚≠ê‚≠ê **Intermedio (70-85%)**
- [ ] Patrones de microservices aplicados
- [ ] Service discovery implementado
- [ ] Circuit breaker patterns
- [ ] Event-driven architecture

#### ‚≠ê‚≠ê‚≠ê **Avanzado (85-95%)**
- [ ] Domain-driven design aplicado
- [ ] CQRS y Event Sourcing
- [ ] Saga patterns para transactions
- [ ] Advanced composition patterns

#### ‚≠ê‚≠ê‚≠ê‚≠ê **Excepcional (95-100%)**
- [ ] Self-healing architecture
- [ ] Zero-downtime deployments
- [ ] Multi-tenant architecture
- [ ] Advanced security patterns

### üöÄ **Implementaci√≥n T√©cnica (25%)**

#### ‚≠ê **B√°sico (60-70%)**
- [ ] Servicios gRPC funcionales
- [ ] CRUD operations implementadas
- [ ] Error handling b√°sico
- [ ] Cliente b√°sico funcional

#### ‚≠ê‚≠ê **Intermedio (70-85%)**
- [ ] Streaming patterns implementados
- [ ] Connection pooling
- [ ] Authentication y authorization
- [ ] Rate limiting

#### ‚≠ê‚≠ê‚≠ê **Avanzado (85-95%)**
- [ ] Performance optimizations
- [ ] Advanced caching strategies
- [ ] Distributed transactions
- [ ] Message queue integration

#### ‚≠ê‚≠ê‚≠ê‚≠ê **Excepcional (95-100%)**
- [ ] Custom protocols y optimizations
- [ ] Machine learning integration
- [ ] Real-time processing
- [ ] Advanced security features

### üîç **Observabilidad y Monitoring (20%)**

#### ‚≠ê **B√°sico (60-70%)**
- [ ] Basic logging implementado
- [ ] Health checks
- [ ] Simple metrics collection
- [ ] Error tracking

#### ‚≠ê‚≠ê **Intermedio (70-85%)**
- [ ] Structured logging
- [ ] Prometheus metrics
- [ ] Basic dashboards
- [ ] Alert rules

#### ‚≠ê‚≠ê‚≠ê **Avanzado (85-95%)**
- [ ] Distributed tracing
- [ ] Business metrics
- [ ] Advanced dashboards
- [ ] SLA monitoring

#### ‚≠ê‚≠ê‚≠ê‚≠ê **Excepcional (95-100%)**
- [ ] Predictive monitoring
- [ ] Automated remediation
- [ ] Advanced analytics
- [ ] ML-based anomaly detection

### ‚ö° **Performance y Scalabilidad (15%)**

#### ‚≠ê **B√°sico (60-70%)**
- [ ] Basic performance acceptable
- [ ] Simple load testing
- [ ] Basic optimization
- [ ] Resource usage monitoring

#### ‚≠ê‚≠ê **Intermedio (70-85%)**
- [ ] Connection pooling optimized
- [ ] Caching implemented
- [ ] Load balancing configured
- [ ] Performance benchmarks

#### ‚≠ê‚≠ê‚≠ê **Avanzado (85-95%)**
- [ ] Advanced optimization techniques
- [ ] Horizontal scaling implemented
- [ ] Performance tuning documented
- [ ] Capacity planning

#### ‚≠ê‚≠ê‚≠ê‚≠ê **Excepcional (95-100%)**
- [ ] Sub-millisecond latencies
- [ ] Auto-scaling implemented
- [ ] Performance regression detection
- [ ] Edge optimization

### üß™ **Testing y Quality (15%)**

#### ‚≠ê **B√°sico (60-70%)**
- [ ] Unit tests b√°sicos
- [ ] Integration tests simples
- [ ] Manual testing
- [ ] Code coverage >60%

#### ‚≠ê‚≠ê **Intermedio (70-85%)**
- [ ] Comprehensive unit tests
- [ ] Automated integration tests
- [ ] Performance tests
- [ ] Code coverage >80%

#### ‚≠ê‚≠ê‚≠ê **Avanzado (85-95%)**
- [ ] End-to-end testing
- [ ] Contract testing
- [ ] Chaos engineering
- [ ] Security testing

#### ‚≠ê‚≠ê‚≠ê‚≠ê **Excepcional (95-100%)**
- [ ] Property-based testing
- [ ] Automated security scanning
- [ ] Production testing
- [ ] Continuous quality gates

---

## üéì Recursos de Referencia

### üìö **Documentaci√≥n Oficial**
- [gRPC Documentation](https://grpc.io/docs/)
- [Protocol Buffers Language Guide](https://developers.google.com/protocol-buffers/docs/proto3)
- [Go gRPC Tutorial](https://grpc.io/docs/languages/go/quickstart/)
- [gRPC Best Practices](https://grpc.io/docs/guides/performance/)

### üõ†Ô∏è **Tools y Utilities**
- [grpcurl](https://github.com/fullstorydev/grpcurl) - Command line tool
- [Evans](https://github.com/ktr0731/evans) - gRPC client
- [Buf](https://buf.build/) - Protocol buffer toolchain
- [grpc-gateway](https://github.com/grpc-ecosystem/grpc-gateway) - REST gateway

### üìñ **Books y References**
- "Building Microservices" by Sam Newman
- "gRPC: Up and Running" by Kasun Indrasiri
- "Microservices Patterns" by Chris Richardson
- "Production-Ready Microservices" by Susan Fowler

### üåê **Community Resources**
- [gRPC Community](https://grpc.io/community/)
- [CNCF Projects](https://www.cncf.io/projects/)
- [Microservices.io](https://microservices.io/)
- [High Scalability](http://highscalability.com/)

---

## üèÅ Entrega y Timeline

### üìÖ **Timeline Sugerido**

#### **Semana 1-2: Foundation**
- [ ] Protocol Buffers design
- [ ] Basic service implementation
- [ ] Development environment setup
- [ ] Core infrastructure

#### **Semana 3-4: Core Services**
- [ ] User Service implementation
- [ ] Product Service implementation
- [ ] Order Service implementation
- [ ] Basic integration testing

#### **Semana 5-6: Advanced Features**
- [ ] Payment Service implementation
- [ ] Inventory Service implementation
- [ ] Notification Service implementation
- [ ] Analytics Service implementation

#### **Semana 7-8: API Gateway**
- [ ] Gateway implementation
- [ ] Service composition
- [ ] Advanced routing
- [ ] Performance optimization

#### **Semana 9-10: Observability**
- [ ] Monitoring setup
- [ ] Logging infrastructure
- [ ] Distributed tracing
- [ ] Alerting configuration

#### **Semana 11-12: Deployment & Testing**
- [ ] Containerization
- [ ] Kubernetes deployment
- [ ] Load testing
- [ ] Documentation completion

### üì¶ **Entrega Final**

#### **Formato de Entrega**
- [ ] GitHub repository con c√≥digo completo
- [ ] Docker Compose setup funcional
- [ ] README detallado con instrucciones
- [ ] Documentation en `/docs`
- [ ] Demo video (15-20 minutos)

#### **Estructura del Repository**
```
grpc-ecommerce/
‚îú‚îÄ‚îÄ README.md (instrucciones setup)
‚îú‚îÄ‚îÄ ARCHITECTURE.md (documentaci√≥n t√©cnica)
‚îú‚îÄ‚îÄ DEMO.md (gu√≠a de demo)
‚îú‚îÄ‚îÄ docker-compose.yml
‚îú‚îÄ‚îÄ Makefile
‚îî‚îÄ‚îÄ [resto de estructura detallada arriba]
```

#### **Demo Requirements**
- [ ] Live demonstration del sistema
- [ ] Performance metrics presentation
- [ ] Architecture walkthrough
- [ ] Q&A session
- [ ] Code review highlights

---

**üöÄ ¬°Es hora de construir el sistema gRPC m√°s avanzado de tu carrera!**

> **üí° Pro Tip**: Empieza con los servicios core, aseg√∫rate de que funcionen bien, luego a√±ade features avanzadas progresivamente. ¬°La calidad es m√°s importante que la cantidad!

**üéØ Pr√≥ximo**: [Resumen de la Lecci√≥n](./RESUMEN.md)
